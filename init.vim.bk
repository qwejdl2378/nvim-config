
call plug#begin('~/.vim/plugged')
Plug 'scrooloose/nerdtree'
Plug 'Xuyuanp/nerdtree-git-plugin'
Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
Plug 'junegunn/fzf.vim'
Plug 'morhetz/gruvbox'
"Plug 'neoclide/coc.nvim', {'branch': 'release'}
"Plug 'leafgarland/typescript-vim'
Plug 'andymass/vim-matchup'
"Plug 'leafoftree/vim-vue-plugin'
Plug 'rhysd/git-messenger.vim'
"Plug 'autozimu/LanguageClient-neovim', {
"    \ 'branch': 'next',
"    \ 'do': 'bash install.sh',
"    \ }
Plug 'neovim/nvim-lspconfig'
Plug 'preservim/nerdcommenter'
Plug 'tpope/vim-surround'
call plug#end()
colorscheme gruvbox
lua require('lsp')


" 打开关闭tree
map <C-z> :NERDTreeToggle<CR>
let NERDTreeShowHidden=1
let NERDTreeKeepTreeInNewTab=1
let g:NERDTreeGitStatusIndicatorMapCustom = {
    \ "Modified"  : "✹",
    \ "Staged"    : "✚",
    \ "Untracked" : "✭",
    \ "Renamed"   : "➜",
    \ "Unmerged"  : "═",
    \ "Deleted"   : "✖",
    \ "Dirty"     : "✗",
    \ "Clean"     : "✔︎",
    \ 'Ignored'   : '☒',
    \ "Unknown"   : "?"
    \ }
" 打开目录自动打开nerdtree
autocmd VimEnter * if argc() == 1 && isdirectory(argv()[0]) && !exists("s:std_in") | exe 'NERDTree' argv()[0] | wincmd p | ene | exe 'cd '.argv()[0] | endif

" fzf颜色
let g:fzf_colors =
\ { 'fg':      ['fg', 'Normal'],
  \ 'bg':      ['bg', 'Normal'],
  \ 'hl':      ['fg', 'Comment'],
  \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
  \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
  \ 'hl+':     ['fg', 'Statement'],
  \ 'info':    ['fg', 'PreProc'],
  \ 'border':  ['fg', 'Ignore'],
  \ 'prompt':  ['fg', 'Conditional'],
  \ 'pointer': ['fg', 'Exception'],
  \ 'marker':  ['fg', 'Keyword'],
  \ 'spinner': ['fg', 'Label'],
  \ 'header':  ['fg', 'Comment'] }

" tab间移动
nmap <C-J> <C-W>j
nmap <C-K> <C-W>k
nmap <C-L> <C-W>l
nmap <C-H> <C-W>h

" -------------------------nerdcommenter start ---------------------------------
" Create default mappings
let g:NERDCreateDefaultMappings = 1

" Add spaces after comment delimiters by default
let g:NERDSpaceDelims = 1

" Use compact syntax for prettified multi-line comments
let g:NERDCompactSexyComs = 1

" Align line-wise comment delimiters flush left instead of following code indentation
let g:NERDDefaultAlign = 'left'

" Set a language to use its alternate delimiters by default
let g:NERDAltDelims_java = 1

" Add your own custom formats or override the defaults
let g:NERDCustomDelimiters = { 'c': { 'left': '/**','right': '*/' } }

" Allow commenting and inverting empty lines (useful when commenting a region)
let g:NERDCommentEmptyLines = 1

" Enable trimming of trailing whitespace when uncommenting
let g:NERDTrimTrailingWhitespace = 1

" Enable NERDCommenterToggle to check all selected lines is commented or not 
let g:NERDToggleCheckAllLines = 1
" -------------------------nerdcommenter end ---------------------------------

set backspace=2
set nocompatible
set number

set softtabstop=4               " Let backspace delete indent
set splitright                  " Puts new vsplit windows to the right of the current
set splitbelow                  " Puts new split windows to the bottom of the current

let mapleader=","

syntax on
filetype indent plugin on

" 补全配置
inoremap <silent><expr> <TAB>
      \ pumvisible() ? "\<C-n>" :
      \ <SID>check_back_space() ? "\<TAB>" :
      \ coc#refresh()

inoremap <expr><S-TAB> pumvisible() ? "\<C-p>" : "\<C-h>"


nmap mm <Plug>(git-messenger)

" prettier命令
command! -nargs=0 Prettier :CocCommand prettier.formatFile
vmap <leader>f  <Plug>(coc-format-selected)
nmap <leader>f  <Plug>(coc-format-selected)

" 代码折叠
set foldmethod=indent
set foldlevel=99


"  autocmd BufNewFile,BufRead *.tsx set filetype=typescript.tsx syntax=typescript.tsx
"  autocmd BufNewFile,BufRead *.jsx set filetype=javascript.jsx syntax=javascript.jsx
"  autocmd BufNewFile,BufRead *.mdx set filetype=mdx syntax=markdown
"  autocmd FileType html,css,scss,less,javascript,typescript,json,javascript.jsx,typescript.tsx,vue,mdx,yaml setlocal tabstop=2 shiftwidth=2 softtabstop=2





"  if exists('*complete_info')
"    inoremap <expr> <C-c> complete_info()["selected"] != "-1" ? "\<C-y>" : "\<C-g>u\<CR>"
"  else
"    imap <expr> <C-c> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
"  endif

"  nmap <silent> gd <Plug>(coc-definition)
"  nmap <silent> gy <Plug>(coc-type-definition)
"  nmap <silent> gi <Plug>(coc-implementation)
"  nmap <silent> gr <Plug>(coc-references)

" 括号换行+1行
"  let g:delimitMate_expand_cr = 1
"  let g:delimitMate_expand_space = 1
"  let g:loaded_matchit = 1

" gopls
" Launch gopls when Go files are in use
"  let g:LanguageClient_serverCommands = {
"         \ 'go': ['gopls']
"         \ }
" Run gofmt on save
"  autocmd BufWritePre *.go :call LanguageClient#textDocument_formatting_sync()



" 绑定自定义的命令
"  map <M-d> <Esc><CR>
"  imap kj <Esc>
"  nmap zz za

"inoremap pp o<Esc>

"  let g:vim_vue_plugin_load_full_syntax = 1


" note that if you are using Plug mapping you should not use `noremap` mappings.
"  nmap <F5> <Plug>(lcn-menu)
" Or map each action separately
"  nmap <silent>K <Plug>(lcn-hover)
"  nmap <silent> gd <Plug>(lcn-definition)
"  nmap <silent> <F2> <Plug>(lcn-rename)


